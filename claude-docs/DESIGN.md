# PyEurisko Design Document 
(generated by Claude)

## Overview
PyEurisko implements a reflexive heuristic system where heuristics are first-class units that can inspect and modify other units, including themselves. The system maintains execution context and history through a centralized context manager, enabling heuristics to learn from their execution patterns.

## Core Components

### Units and Heuristics
Units form the fundamental building blocks of the system. Heuristics are specialized units with procedural slots that define their behavior:

```python
def heuristic(name, isa=None, worth=None):
    def wrapper(cls):
        def create():
            h = Unit(name)
            h.slots['isa'] = isa or ['heuristic', 'op', 'anything']
            h.slots['worth'] = worth or 500
            
            for attr in dir(cls):
                if attr.startswith('if_') or attr.startswith('then_'):
                    h.slots[attr] = getattr(cls, attr).__get__(None, cls)
            return h
        return create
    return wrapper
```

This decorator pattern allows clean definition of heuristics while maintaining their nature as units. Each heuristic is defined by its procedural slots that operate on the execution context.

### Execution Context
The context maintains all state for the current execution:

```python
class ExecutionContext:
    def __init__(self):
        # Current execution state
        self.current_unit = None
        self.current_slot = None 
        self.current_task = None
        self.current_supports = {}

        # Changes being made
        self.old_value = None
        self.new_value = None
        self.u_diff = None
        
        # Results being accumulated
        self.new_units = []
        self.task_results = []
        self.heuristic_records = {}

    def update_record(self, heuristic, success):
        if heuristic.name not in self.heuristic_records:
            self.heuristic_records[heuristic.name] = []
        self.heuristic_records[heuristic.name].append({
            'success': success,
            'changes': self.u_diff,
            'new_units': self.new_units.copy()
        })
```

### Task Manager
The task manager orchestrates heuristic execution:

```python
class TaskManager:
    def __init__(self):
        self.context = ExecutionContext()
        self.agenda = []
        self.heuristics = {}

    def execute_task(self, task):
        self.context.current_task = task
        self.context.current_unit = task.unit
        self.context.current_slot = task.slot
        self.context.current_supports = task.supports

        for heuristic in self.select_heuristics(task):
            success = self.apply_heuristic(heuristic)
            if success:
                self.process_results()

        self.context.clear_for_next()

    def apply_heuristic(self, heuristic):
        # Execute each procedural slot in sequence
        for slot in ['if_working_on_task', 'then_compute', 'then_define_new_concepts']:
            if slot not in heuristic.slots:
                continue
            if not heuristic.slots[slot](self.context):
                self.context.update_record(heuristic, False)
                return False
        
        self.context.update_record(heuristic, True)
        return True

    def process_results(self):
        # Add new tasks to agenda based on results
        for new_unit in self.context.new_units:
            self.agenda.extend(self.generate_tasks(new_unit))
```

## Execution Flow

1. A task is selected from the agenda
2. The task manager sets up the execution context
3. Relevant heuristics are selected
4. Each heuristic's slots are executed in sequence:
   - if_working_on_task checks applicability
   - then_compute performs modifications
   - then_define_new_concepts creates new units
5. Results are processed and new tasks generated
6. Execution statistics are recorded

## Example Heuristic Implementation

```python
@heuristic('h6', worth=700)
class H6:
    @staticmethod
    def if_working_on_task(ctx):
        return (is_specialization_task(ctx.current_slot) and 
                'slot_to_change' in ctx.current_supports)

    @staticmethod 
    def then_compute(ctx):
        ctx.slot_to_change = ctx.current_supports['slot_to_change']
        ctx.old_value = ctx.current_unit.get_slot(ctx.slot_to_change)
        ctx.new_value = specialize_value(ctx.old_value)
        return ctx.old_value != ctx.new_value

    @staticmethod
    def then_define_new_concepts(ctx):
        new_unit = ctx.current_unit.copy()
        new_unit.set_slot(ctx.slot_to_change, ctx.new_value)
        ctx.new_units.append(new_unit)
        ctx.current_unit.add_specialization(new_unit)
        new_unit.add_generalization(ctx.current_unit)
        return True
```

This implementation preserves the reflexive nature of the original Eurisko while providing a cleaner, more maintainable structure. The context-based execution model enables proper tracking of state and history while keeping heuristic implementations focused on their core logic.

The key improvement over the original Lisp implementation is the centralized context management, replacing the dynamic scope variables with explicit state tracking. This makes the system's behavior more predictable while maintaining the power of the original design.
